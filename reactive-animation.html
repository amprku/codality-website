<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Crosshair Logo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        .crosshair-logo-container {
            position: relative;
            width: 100%;
            height: 100vh;
            background: #1a1a1a;
            overflow: hidden;
        }
        
        .crosshair-logo-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .crosshair-logo-info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="crosshair-logo-container">
        <div class="crosshair-logo-info">
            Move mouse to interact â€¢ Click to animate
        </div>
        <canvas class="crosshair-logo-canvas"></canvas>
    </div>
    
    <script>
        class InteractiveCrosshairLogo {
            constructor(container) {
                this.container = container;
                this.canvas = container.querySelector('.crosshair-logo-canvas');
                this.mouse = new THREE.Vector2();
                this.isAnimating = false;
                this.time = 0;
                
                this.init();
                this.createLogo();
                this.setupEventListeners();
                this.animate();
            }
            
            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    this.container.offsetWidth / this.container.offsetHeight, 
                    0.1, 
                    1000
                );
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: this.canvas,
                    antialias: true 
                });
                
                this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
                this.renderer.setClearColor(0x1a1a1a);
                this.camera.position.z = 8;
            }
            
            createRing(innerRadius, outerRadius, segments = 64) {
                const shape = new THREE.Shape();
                shape.arc(0, 0, outerRadius, 0, Math.PI * 2, false);
                
                const hole = new THREE.Path();
                hole.arc(0, 0, innerRadius, 0, Math.PI * 2, true);
                shape.holes.push(hole);
                
                return new THREE.ShapeGeometry(shape, segments);
            }
            
            createSegmentedRing(innerRadius, outerRadius, segments = 8, gapAngle = 0.3, ringIndex = 0) {
                const group = new THREE.Group();
                const segmentAngle = (Math.PI * 2) / segments;
                
                for (let i = 0; i < segments; i++) {
                    const startAngle = i * segmentAngle + gapAngle / 2;
                    const endAngle = (i + 1) * segmentAngle - gapAngle / 2;
                    
                    const shape = new THREE.Shape();
                    shape.arc(0, 0, outerRadius, startAngle, endAngle, false);
                    shape.arc(0, 0, innerRadius, endAngle, startAngle, true);
                    
                    const geometry = new THREE.ShapeGeometry(shape, 32);
                    const material = this.createGradientMaterial(ringIndex);
                    const segment = new THREE.Mesh(geometry, material);
                    group.add(segment);
                }
                
                return group;
            }
            
            createGradientMaterial(ringIndex) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
                
                if (ringIndex === 0) { // Outer ring - more red-orange
                    gradient.addColorStop(0, '#ff8c00');
                    gradient.addColorStop(0.4, '#ff6600');
                    gradient.addColorStop(1, '#ff4500');
                } else if (ringIndex === 1) { // Middle ring - orange
                    gradient.addColorStop(0, '#ffaa00');
                    gradient.addColorStop(0.5, '#ff8800');
                    gradient.addColorStop(1, '#ff5500');
                } else { // Inner ring - yellow-orange
                    gradient.addColorStop(0, '#ffcc00');
                    gradient.addColorStop(0.3, '#ffaa00');
                    gradient.addColorStop(1, '#ff7700');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 256, 256);
                
                const texture = new THREE.CanvasTexture(canvas);
                return new THREE.MeshBasicMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.9
                });
            }
            
            createCrosshairCircle(radius, thickness = 0.1) {
                const geometry = new THREE.RingGeometry(radius - thickness, radius + thickness, 128);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                
                return new THREE.Mesh(geometry, material);
            }
            
            createCrosshairLine(length, width) {
                const geometry = new THREE.PlaneGeometry(length, width);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.95
                });
                return new THREE.Mesh(geometry, material);
            }
            
            createCenterDot() {
                const geometry = new THREE.CircleGeometry(0.15, 32);
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, '#ff8800');
                gradient.addColorStop(0.7, '#ff5500');
                gradient.addColorStop(1, '#cc3300');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 64, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.95
                });
                
                return new THREE.Mesh(geometry, material);
            }
            
            createLogo() {
                this.logoGroup = new THREE.Group();
                
                // Create rings with proper z-layering
                this.outerRing = this.createSegmentedRing(2.8, 3.5, 8, 0.4, 0);
                this.outerRing.position.z = -0.3;
                this.logoGroup.add(this.outerRing);
                
                this.middleRing = this.createSegmentedRing(2.2, 2.6, 8, 0.3, 1);
                this.middleRing.position.z = -0.2;
                this.logoGroup.add(this.middleRing);
                
                this.innerRing = this.createSegmentedRing(1.5, 1.8, 6, 0.5, 2);
                this.innerRing.position.z = -0.1;
                this.logoGroup.add(this.innerRing);
                
                // Create crosshair circles
                this.middleCircle = this.createCrosshairCircle(2.4, 0.05);
                this.middleCircle.position.z = 0.1;
                this.logoGroup.add(this.middleCircle);
                
                this.innerCircle = this.createCrosshairCircle(1.6, 0.04);
                this.innerCircle.position.z = 0.2;
                this.logoGroup.add(this.innerCircle);
                
                // Create crosshair lines
                this.horizontalLine = this.createCrosshairLine(6, 0.2);
                this.horizontalLine.position.z = 0.3;
                this.logoGroup.add(this.horizontalLine);
                
                this.verticalLine = this.createCrosshairLine(0.2, 6);
                this.verticalLine.position.z = 0.3;
                this.logoGroup.add(this.verticalLine);
                
                // Create center dot
                this.centerDot = this.createCenterDot();
                this.centerDot.position.z = 0.4;
                this.logoGroup.add(this.centerDot);
                
                this.scene.add(this.logoGroup);
            }
            
            setupEventListeners() {
                this.onMouseMove = this.onMouseMove.bind(this);
                this.onClick = this.onClick.bind(this);
                this.onWindowResize = this.onWindowResize.bind(this);
                
                this.container.addEventListener('mousemove', this.onMouseMove);
                this.container.addEventListener('click', this.onClick);
                window.addEventListener('resize', this.onWindowResize);
            }
            
            onMouseMove(event) {
                const rect = this.container.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            }
            
            onClick() {
                this.isAnimating = !this.isAnimating;
            }
            
            onWindowResize() {
                const width = this.container.offsetWidth;
                const height = this.container.offsetHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.time += 0.01;
                
                // Mouse interaction
                const targetRotationY = this.mouse.x * 0.3;
                const targetRotationX = this.mouse.y * 0.3;
                
                this.logoGroup.rotation.y += (targetRotationY - this.logoGroup.rotation.y) * 0.05;
                this.logoGroup.rotation.x += (targetRotationX - this.logoGroup.rotation.x) * 0.05;
                
                if (this.isAnimating) {
                    // Fast rotation when animating
                    this.outerRing.rotation.z += 0.02;
                    this.middleRing.rotation.z -= 0.025;
                    this.innerRing.rotation.z += 0.03;
                    this.middleCircle.rotation.z += 0.015;
                    this.innerCircle.rotation.z -= 0.02;
                    
                    // Pulsing effect
                    const scale = 1 + Math.sin(this.time * 2) * 0.05;
                    this.logoGroup.scale.set(scale, scale, scale);
                    
                    // Color shifting
                    const hue = 15 + Math.sin(this.time * 2) * 10;
                    this.centerDot.material.color.setHSL(hue / 360, 0.9, 0.6);
                } else {
                    // Gentle idle rotation
                    this.outerRing.rotation.z += 0.003;
                    this.middleRing.rotation.z -= 0.002;
                    this.innerRing.rotation.z += 0.004;
                    this.middleCircle.rotation.z += 0.0015;
                    this.innerCircle.rotation.z -= 0.002;
                    
                    // Return to normal scale
                    const targetScale = 1;
                    this.logoGroup.scale.x += (targetScale - this.logoGroup.scale.x) * 0.1;
                    this.logoGroup.scale.y += (targetScale - this.logoGroup.scale.y) * 0.1;
                    this.logoGroup.scale.z += (targetScale - this.logoGroup.scale.z) * 0.1;
                    
                    // Return center dot to orange
                    this.centerDot.material.color.lerp(new THREE.Color(0xff5500), 0.05);
                }
                
                // Floating animation
                this.logoGroup.position.y = Math.sin(this.time * 0.5) * 0.1;
                
                // Crosshair glow effect
                const glowIntensity = 0.8 + Math.sin(this.time * 3) * 0.2;
                this.horizontalLine.material.opacity = glowIntensity;
                this.verticalLine.material.opacity = glowIntensity;
                
                this.renderer.render(this.scene, this.camera);
            }
            
            destroy() {
                this.container.removeEventListener('mousemove', this.onMouseMove);
                this.container.removeEventListener('click', this.onClick);
                window.removeEventListener('resize', this.onWindowResize);
                
                // Clean up Three.js resources
                this.scene.clear();
                this.renderer.dispose();
            }
        }
        
        // Initialize the logo
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.querySelector('.crosshair-logo-container');
            new InteractiveCrosshairLogo(container);
        });
    </script>
</body>
</html>